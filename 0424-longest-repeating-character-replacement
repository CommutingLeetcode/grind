class Solution:
    def characterReplacement(self, s: str, k: int) -> int:
        # sliding window
        l = 0
        
        # map for counting # of occurences of each character in the window
        count = {}
        maxF = 0
        res = 0
        
        for r in range (0, len(s)):
            # update the count map with the latest character
            count[s[r]] = 1 + count.get(s[r], 0)
            
            # update the maxF variable to store the character w/ the most occurences in the window
            maxF = max(maxF, count[s[r]])

            # see if len(window) - most repeated character in the window <= k
            valid = (((r - l + 1) - maxF) <= k)
            
            # update the res
            if valid:
                res = max(res, r - l + 1)
                
            # increase left pointer if not valid
            if not valid:
                count[s[l]] -= 1
                l += 1
                
        return res
        
'''
I haven't solved a sliding window in a while. But this refreshes my mind on it. Usually, the loop is a for loop and we use the right pointer as the iterator.
things to note:
1. you don't actually require a res variable, as the size of the sliding window will maintain itself to the end of the list (it will not increase more than the largest valid sliding window)
2. in the neetcode solution, we're using a while loop to update the left pointer. But that's not needed because just by incrementing l by 1, we're already in the valid range

O(n) time and space complexity
'''
