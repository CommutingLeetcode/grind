class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        #input is a [int] and an int
        #output is a [int]
        #1,3,5,1,3
        count = {}
        solution = [[] for _ in range(len(nums))]
        output = []
        
        #define a count list
        
        #iterate through nums
        for num in nums:
            #increment number of occurence by 1 in count list
            count[num] = count.get(num, 0) + 1
        
        print("count", count)
        
        #store it in a preallocated list of lists, so that we can go from most occurences to least
        for number, occurence in count.items():
            solution[occurence - 1].append(number)
            
        print("solution", solution)
        #iterate count from the end
        for i in range(len(solution)-1, -1, -1):
            for j in solution[i]:
                print("j", j)
                output.append(j)
                if len(output) == k:
                    return output
        
        
'''
This one, what you have to remember is how we can use a preallocated array to help iterate from the most frequency to least frequency. Why can we use an array? Because we know there's a max to that array which is the length of the input list (extreme case being a list of all the same numbers).

from that, we can use this to iterate the loop from the most frequency, until the top k most frequent elements are found.
time complexity: O(n) because we're just iterating through the lists, although it seems like there are 2 for loops at the end, it is bound to end when len of output is k, which will always be constant

space complexity: O(n) for count, O(n) for solution, and O(k) for output
'''
